<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ROSS: core/lz4.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ROSS
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">core/lz4.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="lz4_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">   LZ4 - Fast LZ compression algorithm</span>
<a name="l00003"></a>00003 <span class="comment">   Header File</span>
<a name="l00004"></a>00004 <span class="comment">   Copyright (C) 2011-2015, Yann Collet.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">   Redistribution and use in source and binary forms, with or without</span>
<a name="l00009"></a>00009 <span class="comment">   modification, are permitted provided that the following conditions are</span>
<a name="l00010"></a>00010 <span class="comment">   met:</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">       * Redistributions of source code must retain the above copyright</span>
<a name="l00013"></a>00013 <span class="comment">   notice, this list of conditions and the following disclaimer.</span>
<a name="l00014"></a>00014 <span class="comment">       * Redistributions in binary form must reproduce the above</span>
<a name="l00015"></a>00015 <span class="comment">   copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00016"></a>00016 <span class="comment">   in the documentation and/or other materials provided with the</span>
<a name="l00017"></a>00017 <span class="comment">   distribution.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00020"></a>00020 <span class="comment">   &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00021"></a>00021 <span class="comment">   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00022"></a>00022 <span class="comment">   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00023"></a>00023 <span class="comment">   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00024"></a>00024 <span class="comment">   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00025"></a>00025 <span class="comment">   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00026"></a>00026 <span class="comment">   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00027"></a>00027 <span class="comment">   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00028"></a>00028 <span class="comment">   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00029"></a>00029 <span class="comment">   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">   You can contact the author at :</span>
<a name="l00032"></a>00032 <span class="comment">   - LZ4 source repository : https://github.com/Cyan4973/lz4</span>
<a name="l00033"></a>00033 <span class="comment">   - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c</span>
<a name="l00034"></a>00034 <span class="comment">*/</span>
<a name="l00035"></a>00035 <span class="preprocessor">#pragma once</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 <span class="preprocessor">#if defined (__cplusplus)</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00039"></a>00039 <span class="preprocessor">#endif</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="comment">/*</span>
<a name="l00042"></a>00042 <span class="comment"> * lz4.h provides block compression functions, and gives full buffer control to programmer.</span>
<a name="l00043"></a>00043 <span class="comment"> * If you need to generate inter-operable compressed data (respecting LZ4 frame specification),</span>
<a name="l00044"></a>00044 <span class="comment"> * and can let the library handle its own memory, please use lz4frame.h instead.</span>
<a name="l00045"></a>00045 <span class="comment">*/</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="comment">/**************************************</span>
<a name="l00048"></a>00048 <span class="comment">*  Version</span>
<a name="l00049"></a>00049 <span class="comment">**************************************/</span>
<a name="l00050"></a><a class="code" href="lz4_8h.html#a4a15eb1f8aa69834f917a50d7652413e">00050</a> <span class="preprocessor">#define LZ4_VERSION_MAJOR    1    </span><span class="comment">/* for breaking interface changes  */</span>
<a name="l00051"></a><a class="code" href="lz4_8h.html#af16952f74f68ac445da9fc7603609909">00051</a> <span class="preprocessor">#define LZ4_VERSION_MINOR    7    </span><span class="comment">/* for new (non-breaking) interface capabilities */</span>
<a name="l00052"></a><a class="code" href="lz4_8h.html#a19d496bbe4d8448bc2d42cfb576cf525">00052</a> <span class="preprocessor">#define LZ4_VERSION_RELEASE  0    </span><span class="comment">/* for tweaks, bug-fixes, or development */</span>
<a name="l00053"></a><a class="code" href="lz4_8h.html#aac7e910a11c45364a8b235d0d43a0265">00053</a> <span class="preprocessor">#define LZ4_VERSION_NUMBER (LZ4_VERSION_MAJOR *100*100 + LZ4_VERSION_MINOR *100 + LZ4_VERSION_RELEASE)</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a9a7a69397b6452fcf6a35caa40493776">LZ4_versionNumber</a> (<span class="keywordtype">void</span>);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/**************************************</span>
<a name="l00057"></a>00057 <span class="comment">*  Tuning parameter</span>
<a name="l00058"></a>00058 <span class="comment">**************************************/</span>
<a name="l00059"></a>00059 <span class="comment">/*</span>
<a name="l00060"></a>00060 <span class="comment"> * LZ4_MEMORY_USAGE :</span>
<a name="l00061"></a>00061 <span class="comment"> * Memory usage formula : N-&gt;2^N Bytes (examples : 10 -&gt; 1KB; 12 -&gt; 4KB ; 16 -&gt; 64KB; 20 -&gt; 1MB; etc.)</span>
<a name="l00062"></a>00062 <span class="comment"> * Increasing memory usage improves compression ratio</span>
<a name="l00063"></a>00063 <span class="comment"> * Reduced memory usage can improve speed, due to cache effect</span>
<a name="l00064"></a>00064 <span class="comment"> * Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache</span>
<a name="l00065"></a>00065 <span class="comment"> */</span>
<a name="l00066"></a><a class="code" href="lz4_8h.html#a24ddbc39e7379532031a91357e66a32c">00066</a> <span class="preprocessor">#define LZ4_MEMORY_USAGE 14</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">/**************************************</span>
<a name="l00070"></a>00070 <span class="comment">*  Simple Functions</span>
<a name="l00071"></a>00071 <span class="comment">**************************************/</span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a35d5204eebb64d3caa3aa7c902166e28">LZ4_compress_default</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> sourceSize, <span class="keywordtype">int</span> maxDestSize);
<a name="l00074"></a>00074 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a0826f3dc340fdea6dfa985f6ac26642f">LZ4_decompress_safe</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> maxDecompressedSize);
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="comment">/*</span>
<a name="l00077"></a>00077 <span class="comment">LZ4_compress_default() :</span>
<a name="l00078"></a>00078 <span class="comment">    Compresses &#39;sourceSize&#39; bytes from buffer &#39;source&#39;</span>
<a name="l00079"></a>00079 <span class="comment">    into already allocated &#39;dest&#39; buffer of size &#39;maxDestSize&#39;.</span>
<a name="l00080"></a>00080 <span class="comment">    Compression is guaranteed to succeed if &#39;maxDestSize&#39; &gt;= LZ4_compressBound(sourceSize).</span>
<a name="l00081"></a>00081 <span class="comment">    It also runs faster, so it&#39;s a recommended setting.</span>
<a name="l00082"></a>00082 <span class="comment">    If the function cannot compress &#39;source&#39; into a more limited &#39;dest&#39; budget,</span>
<a name="l00083"></a>00083 <span class="comment">    compression stops *immediately*, and the function result is zero.</span>
<a name="l00084"></a>00084 <span class="comment">    As a consequence, &#39;dest&#39; content is not valid.</span>
<a name="l00085"></a>00085 <span class="comment">    This function never writes outside &#39;dest&#39; buffer, nor read outside &#39;source&#39; buffer.</span>
<a name="l00086"></a>00086 <span class="comment">        sourceSize  : Max supported value is LZ4_MAX_INPUT_VALUE</span>
<a name="l00087"></a>00087 <span class="comment">        maxDestSize : full or partial size of buffer &#39;dest&#39; (which must be already allocated)</span>
<a name="l00088"></a>00088 <span class="comment">        return : the number of bytes written into buffer &#39;dest&#39; (necessarily &lt;= maxOutputSize)</span>
<a name="l00089"></a>00089 <span class="comment">              or 0 if compression fails</span>
<a name="l00090"></a>00090 <span class="comment"></span>
<a name="l00091"></a>00091 <span class="comment">LZ4_decompress_safe() :</span>
<a name="l00092"></a>00092 <span class="comment">    compressedSize : is the precise full size of the compressed block.</span>
<a name="l00093"></a>00093 <span class="comment">    maxDecompressedSize : is the size of destination buffer, which must be already allocated.</span>
<a name="l00094"></a>00094 <span class="comment">    return : the number of bytes decompressed into destination buffer (necessarily &lt;= maxDecompressedSize)</span>
<a name="l00095"></a>00095 <span class="comment">             If destination buffer is not large enough, decoding will stop and output an error code (&lt;0).</span>
<a name="l00096"></a>00096 <span class="comment">             If the source stream is detected malformed, the function will stop decoding and return a negative result.</span>
<a name="l00097"></a>00097 <span class="comment">             This function is protected against buffer overflow exploits, including malicious data packets.</span>
<a name="l00098"></a>00098 <span class="comment">             It never writes outside output buffer, nor reads outside input buffer.</span>
<a name="l00099"></a>00099 <span class="comment">*/</span>
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">/**************************************</span>
<a name="l00103"></a>00103 <span class="comment">*  Advanced Functions</span>
<a name="l00104"></a>00104 <span class="comment">**************************************/</span>
<a name="l00105"></a><a class="code" href="lz4_8h.html#a88ee51e36ca74cd0533e731c20572ea6">00105</a> <span class="preprocessor">#define LZ4_MAX_INPUT_SIZE        0x7E000000   </span><span class="comment">/* 2 113 929 216 bytes */</span>
<a name="l00106"></a><a class="code" href="lz4_8h.html#a2453a423fd34640a0afbbf57ed0a5399">00106</a> <span class="preprocessor">#define LZ4_COMPRESSBOUND(isize)  ((unsigned)(isize) &gt; (unsigned)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span>
<a name="l00108"></a>00108 <span class="comment">/*</span>
<a name="l00109"></a>00109 <span class="comment">LZ4_compressBound() :</span>
<a name="l00110"></a>00110 <span class="comment">    Provides the maximum size that LZ4 compression may output in a &quot;worst case&quot; scenario (input data not compressible)</span>
<a name="l00111"></a>00111 <span class="comment">    This function is primarily useful for memory allocation purposes (destination buffer size).</span>
<a name="l00112"></a>00112 <span class="comment">    Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).</span>
<a name="l00113"></a>00113 <span class="comment">    Note that LZ4_compress_default() compress faster when dest buffer size is &gt;= LZ4_compressBound(srcSize)</span>
<a name="l00114"></a>00114 <span class="comment">        inputSize  : max supported value is LZ4_MAX_INPUT_SIZE</span>
<a name="l00115"></a>00115 <span class="comment">        return : maximum output size in a &quot;worst case&quot; scenario</span>
<a name="l00116"></a>00116 <span class="comment">              or 0, if input size is too large ( &gt; LZ4_MAX_INPUT_SIZE)</span>
<a name="l00117"></a>00117 <span class="comment">*/</span>
<a name="l00118"></a>00118 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a2b09f5ca41ce609bb136d3637beffe04">LZ4_compressBound</a>(<span class="keywordtype">int</span> inputSize);
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">/*</span>
<a name="l00121"></a>00121 <span class="comment">LZ4_compress_fast() :</span>
<a name="l00122"></a>00122 <span class="comment">    Same as LZ4_compress_default(), but allows to select an &quot;acceleration&quot; factor.</span>
<a name="l00123"></a>00123 <span class="comment">    The larger the acceleration value, the faster the algorithm, but also the lesser the compression.</span>
<a name="l00124"></a>00124 <span class="comment">    It&#39;s a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.</span>
<a name="l00125"></a>00125 <span class="comment">    An acceleration value of &quot;1&quot; is the same as regular LZ4_compress_default()</span>
<a name="l00126"></a>00126 <span class="comment">    Values &lt;= 0 will be replaced by ACCELERATION_DEFAULT (see lz4.c), which is 1.</span>
<a name="l00127"></a>00127 <span class="comment">*/</span>
<a name="l00128"></a>00128 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a7466a8eca8f7b2eeec7887c9371d21e1">LZ4_compress_fast</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> sourceSize, <span class="keywordtype">int</span> maxDestSize, <span class="keywordtype">int</span> acceleration);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment">/*</span>
<a name="l00132"></a>00132 <span class="comment">LZ4_compress_fast_extState() :</span>
<a name="l00133"></a>00133 <span class="comment">    Same compression function, just using an externally allocated memory space to store compression state.</span>
<a name="l00134"></a>00134 <span class="comment">    Use LZ4_sizeofState() to know how much memory must be allocated,</span>
<a name="l00135"></a>00135 <span class="comment">    and allocate it on 8-bytes boundaries (using malloc() typically).</span>
<a name="l00136"></a>00136 <span class="comment">    Then, provide it as &#39;void* state&#39; to compression function.</span>
<a name="l00137"></a>00137 <span class="comment">*/</span>
<a name="l00138"></a>00138 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#aa7ea35a4a6f3c9b29dbbd14939706c53">LZ4_sizeofState</a>(<span class="keywordtype">void</span>);
<a name="l00139"></a>00139 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a19a6258c0092d5b3255a41d7566248d7">LZ4_compress_fast_extState</a> (<span class="keywordtype">void</span>* state, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize, <span class="keywordtype">int</span> maxDestSize, <span class="keywordtype">int</span> acceleration);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="comment">/*</span>
<a name="l00143"></a>00143 <span class="comment">LZ4_compress_destSize() :</span>
<a name="l00144"></a>00144 <span class="comment">    Reverse the logic, by compressing as much data as possible from &#39;source&#39; buffer</span>
<a name="l00145"></a>00145 <span class="comment">    into already allocated buffer &#39;dest&#39; of size &#39;targetDestSize&#39;.</span>
<a name="l00146"></a>00146 <span class="comment">    This function either compresses the entire &#39;source&#39; content into &#39;dest&#39; if it&#39;s large enough,</span>
<a name="l00147"></a>00147 <span class="comment">    or fill &#39;dest&#39; buffer completely with as much data as possible from &#39;source&#39;.</span>
<a name="l00148"></a>00148 <span class="comment">        *sourceSizePtr : will be modified to indicate how many bytes where read from &#39;source&#39; to fill &#39;dest&#39;.</span>
<a name="l00149"></a>00149 <span class="comment">                         New value is necessarily &lt;= old value.</span>
<a name="l00150"></a>00150 <span class="comment">        return : Nb bytes written into &#39;dest&#39; (necessarily &lt;= targetDestSize)</span>
<a name="l00151"></a>00151 <span class="comment">              or 0 if compression fails</span>
<a name="l00152"></a>00152 <span class="comment">*/</span>
<a name="l00153"></a>00153 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a54116374080dae219ffa71e484ce5f2a">LZ4_compress_destSize</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span>* sourceSizePtr, <span class="keywordtype">int</span> targetDestSize);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="comment">/*</span>
<a name="l00157"></a>00157 <span class="comment">LZ4_decompress_fast() :</span>
<a name="l00158"></a>00158 <span class="comment">    originalSize : is the original and therefore uncompressed size</span>
<a name="l00159"></a>00159 <span class="comment">    return : the number of bytes read from the source buffer (in other words, the compressed size)</span>
<a name="l00160"></a>00160 <span class="comment">             If the source stream is detected malformed, the function will stop decoding and return a negative result.</span>
<a name="l00161"></a>00161 <span class="comment">             Destination buffer must be already allocated. Its size must be a minimum of &#39;originalSize&#39; bytes.</span>
<a name="l00162"></a>00162 <span class="comment">    note : This function fully respect memory boundaries for properly formed compressed data.</span>
<a name="l00163"></a>00163 <span class="comment">           It is a bit faster than LZ4_decompress_safe().</span>
<a name="l00164"></a>00164 <span class="comment">           However, it does not provide any protection against intentionally modified data stream (malicious input).</span>
<a name="l00165"></a>00165 <span class="comment">           Use this function in trusted environment only (data to decode comes from a trusted source).</span>
<a name="l00166"></a>00166 <span class="comment">*/</span>
<a name="l00167"></a>00167 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a1b6fd5873bbe60abc9a6bf7b3e75056a">LZ4_decompress_fast</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> originalSize);
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="comment">/*</span>
<a name="l00170"></a>00170 <span class="comment">LZ4_decompress_safe_partial() :</span>
<a name="l00171"></a>00171 <span class="comment">    This function decompress a compressed block of size &#39;compressedSize&#39; at position &#39;source&#39;</span>
<a name="l00172"></a>00172 <span class="comment">    into destination buffer &#39;dest&#39; of size &#39;maxDecompressedSize&#39;.</span>
<a name="l00173"></a>00173 <span class="comment">    The function tries to stop decompressing operation as soon as &#39;targetOutputSize&#39; has been reached,</span>
<a name="l00174"></a>00174 <span class="comment">    reducing decompression time.</span>
<a name="l00175"></a>00175 <span class="comment">    return : the number of bytes decoded in the destination buffer (necessarily &lt;= maxDecompressedSize)</span>
<a name="l00176"></a>00176 <span class="comment">       Note : this number can be &lt; &#39;targetOutputSize&#39; should the compressed block to decode be smaller.</span>
<a name="l00177"></a>00177 <span class="comment">             Always control how many bytes were decoded.</span>
<a name="l00178"></a>00178 <span class="comment">             If the source stream is detected malformed, the function will stop decoding and return a negative result.</span>
<a name="l00179"></a>00179 <span class="comment">             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets</span>
<a name="l00180"></a>00180 <span class="comment">*/</span>
<a name="l00181"></a>00181 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a32ad048b557cd0bd1134cc8221dca208">LZ4_decompress_safe_partial</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> targetOutputSize, <span class="keywordtype">int</span> maxDecompressedSize);
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="comment">/***********************************************</span>
<a name="l00185"></a>00185 <span class="comment">*  Streaming Compression Functions</span>
<a name="l00186"></a>00186 <span class="comment">***********************************************/</span>
<a name="l00187"></a><a class="code" href="lz4_8h.html#acddbce79f3e1d413f295e97d986ab3f5">00187</a> <span class="preprocessor">#define LZ4_STREAMSIZE_U64 ((1 &lt;&lt; (LZ4_MEMORY_USAGE-3)) + 4)</span>
<a name="l00188"></a><a class="code" href="lz4_8h.html#a1b76402ebadac569ceb550cb22a7a6e4">00188</a> <span class="preprocessor"></span><span class="preprocessor">#define LZ4_STREAMSIZE     (LZ4_STREAMSIZE_U64 * sizeof(long long))</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00190"></a>00190 <span class="comment"> * LZ4_stream_t</span>
<a name="l00191"></a>00191 <span class="comment"> * information structure to track an LZ4 stream.</span>
<a name="l00192"></a>00192 <span class="comment"> * important : init this structure content before first use !</span>
<a name="l00193"></a>00193 <span class="comment"> * note : only allocated directly the structure if you are statically linking LZ4</span>
<a name="l00194"></a>00194 <span class="comment"> *        If you are using liblz4 as a DLL, please use below construction methods instead.</span>
<a name="l00195"></a>00195 <span class="comment"> */</span>
<a name="l00196"></a><a class="code" href="structLZ4__stream__t.html#ae4d6a1e6e680c9d9b3c3ea383da1d948">00196</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">long</span> <span class="keywordtype">long</span> table[<a class="code" href="lz4_8h.html#acddbce79f3e1d413f295e97d986ab3f5">LZ4_STREAMSIZE_U64</a>]; } <a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>;
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 <span class="comment">/*</span>
<a name="l00199"></a>00199 <span class="comment"> * LZ4_resetStream</span>
<a name="l00200"></a>00200 <span class="comment"> * Use this function to init an allocated LZ4_stream_t structure</span>
<a name="l00201"></a>00201 <span class="comment"> */</span>
<a name="l00202"></a>00202 <span class="keywordtype">void</span> <a class="code" href="lz4_8c.html#a62d9f1ebf60fd83bf2f0d1a58e80a64c">LZ4_resetStream</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* streamPtr);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">/*</span>
<a name="l00205"></a>00205 <span class="comment"> * LZ4_createStream will allocate and initialize an LZ4_stream_t structure</span>
<a name="l00206"></a>00206 <span class="comment"> * LZ4_freeStream releases its memory.</span>
<a name="l00207"></a>00207 <span class="comment"> * In the context of a DLL (liblz4), please use these methods rather than the static struct.</span>
<a name="l00208"></a>00208 <span class="comment"> * They are more future proof, in case of a change of LZ4_stream_t size.</span>
<a name="l00209"></a>00209 <span class="comment"> */</span>
<a name="l00210"></a>00210 <a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* <a class="code" href="lz4_8c.html#a2ee12bd94227e0c76a3b686eee813c91">LZ4_createStream</a>(<span class="keywordtype">void</span>);
<a name="l00211"></a>00211 <span class="keywordtype">int</span>           <a class="code" href="lz4_8c.html#a6a4702cac776d39c52074280d8fb84db">LZ4_freeStream</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* streamPtr);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213 <span class="comment">/*</span>
<a name="l00214"></a>00214 <span class="comment"> * LZ4_loadDict</span>
<a name="l00215"></a>00215 <span class="comment"> * Use this function to load a static dictionary into LZ4_stream.</span>
<a name="l00216"></a>00216 <span class="comment"> * Any previous data will be forgotten, only &#39;dictionary&#39; will remain in memory.</span>
<a name="l00217"></a>00217 <span class="comment"> * Loading a size of 0 is allowed.</span>
<a name="l00218"></a>00218 <span class="comment"> * Return : dictionary size, in bytes (necessarily &lt;= 64 KB)</span>
<a name="l00219"></a>00219 <span class="comment"> */</span>
<a name="l00220"></a>00220 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a2b94615ba633a2c5511758d5f2cb34f5">LZ4_loadDict</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* streamPtr, <span class="keyword">const</span> <span class="keywordtype">char</span>* dictionary, <span class="keywordtype">int</span> dictSize);
<a name="l00221"></a>00221 
<a name="l00222"></a>00222 <span class="comment">/*</span>
<a name="l00223"></a>00223 <span class="comment"> * LZ4_compress_fast_continue</span>
<a name="l00224"></a>00224 <span class="comment"> * Compress buffer content &#39;src&#39;, using data from previously compressed blocks as dictionary to improve compression ratio.</span>
<a name="l00225"></a>00225 <span class="comment"> * Important : Previous data blocks are assumed to still be present and unmodified !</span>
<a name="l00226"></a>00226 <span class="comment"> * &#39;dst&#39; buffer must be already allocated.</span>
<a name="l00227"></a>00227 <span class="comment"> * If maxDstSize &gt;= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.</span>
<a name="l00228"></a>00228 <span class="comment"> * If not, and if compressed data cannot fit into &#39;dst&#39; buffer size, compression stops, and function returns a zero.</span>
<a name="l00229"></a>00229 <span class="comment"> */</span>
<a name="l00230"></a>00230 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#abee2872be58007aae02ca0ca467dae4f">LZ4_compress_fast_continue</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* streamPtr, <span class="keyword">const</span> <span class="keywordtype">char</span>* src, <span class="keywordtype">char</span>* dst, <span class="keywordtype">int</span> srcSize, <span class="keywordtype">int</span> maxDstSize, <span class="keywordtype">int</span> acceleration);
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="comment">/*</span>
<a name="l00233"></a>00233 <span class="comment"> * LZ4_saveDict</span>
<a name="l00234"></a>00234 <span class="comment"> * If previously compressed data block is not guaranteed to remain available at its memory location</span>
<a name="l00235"></a>00235 <span class="comment"> * save it into a safer place (char* safeBuffer)</span>
<a name="l00236"></a>00236 <span class="comment"> * Note : you don&#39;t need to call LZ4_loadDict() afterwards,</span>
<a name="l00237"></a>00237 <span class="comment"> *        dictionary is immediately usable, you can therefore call LZ4_compress_fast_continue()</span>
<a name="l00238"></a>00238 <span class="comment"> * Return : saved dictionary size in bytes (necessarily &lt;= dictSize), or 0 if error</span>
<a name="l00239"></a>00239 <span class="comment"> */</span>
<a name="l00240"></a>00240 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#abb233b63fc3488ce647ee9c7b0a95a76">LZ4_saveDict</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* streamPtr, <span class="keywordtype">char</span>* safeBuffer, <span class="keywordtype">int</span> dictSize);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="comment">/************************************************</span>
<a name="l00244"></a>00244 <span class="comment">*  Streaming Decompression Functions</span>
<a name="l00245"></a>00245 <span class="comment">************************************************/</span>
<a name="l00246"></a>00246 
<a name="l00247"></a><a class="code" href="lz4_8h.html#a414ecb38e0607f239de5ebca5a5beef5">00247</a> <span class="preprocessor">#define LZ4_STREAMDECODESIZE_U64  4</span>
<a name="l00248"></a><a class="code" href="lz4_8h.html#a9a08f1c4969b5e46eba93818cd7cb5a7">00248</a> <span class="preprocessor"></span><span class="preprocessor">#define LZ4_STREAMDECODESIZE     (LZ4_STREAMDECODESIZE_U64 * sizeof(unsigned long long))</span>
<a name="l00249"></a><a class="code" href="structLZ4__streamDecode__t.html#a26d8a3afb360f5fffff4fdb6e59b5ead">00249</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> table[<a class="code" href="lz4_8h.html#a414ecb38e0607f239de5ebca5a5beef5">LZ4_STREAMDECODESIZE_U64</a>]; } <a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>;
<a name="l00250"></a>00250 <span class="comment">/*</span>
<a name="l00251"></a>00251 <span class="comment"> * LZ4_streamDecode_t</span>
<a name="l00252"></a>00252 <span class="comment"> * information structure to track an LZ4 stream.</span>
<a name="l00253"></a>00253 <span class="comment"> * init this structure content using LZ4_setStreamDecode or memset() before first use !</span>
<a name="l00254"></a>00254 <span class="comment"> *</span>
<a name="l00255"></a>00255 <span class="comment"> * In the context of a DLL (liblz4) please prefer usage of construction methods below.</span>
<a name="l00256"></a>00256 <span class="comment"> * They are more future proof, in case of a change of LZ4_streamDecode_t size in the future.</span>
<a name="l00257"></a>00257 <span class="comment"> * LZ4_createStreamDecode will allocate and initialize an LZ4_streamDecode_t structure</span>
<a name="l00258"></a>00258 <span class="comment"> * LZ4_freeStreamDecode releases its memory.</span>
<a name="l00259"></a>00259 <span class="comment"> */</span>
<a name="l00260"></a>00260 <a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* <a class="code" href="lz4_8c.html#a328b12424f9542cbc348b98482e455f5">LZ4_createStreamDecode</a>(<span class="keywordtype">void</span>);
<a name="l00261"></a>00261 <span class="keywordtype">int</span>                 <a class="code" href="lz4_8c.html#afdcbf92c1921ecf2838db322c77c1485">LZ4_freeStreamDecode</a> (<a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* LZ4_stream);
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="comment">/*</span>
<a name="l00264"></a>00264 <span class="comment"> * LZ4_setStreamDecode</span>
<a name="l00265"></a>00265 <span class="comment"> * Use this function to instruct where to find the dictionary.</span>
<a name="l00266"></a>00266 <span class="comment"> * Setting a size of 0 is allowed (same effect as reset).</span>
<a name="l00267"></a>00267 <span class="comment"> * Return : 1 if OK, 0 if error</span>
<a name="l00268"></a>00268 <span class="comment"> */</span>
<a name="l00269"></a>00269 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a971624e4abed2ab679a8c1728875663b">LZ4_setStreamDecode</a> (<a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* LZ4_streamDecode, <span class="keyword">const</span> <span class="keywordtype">char</span>* dictionary, <span class="keywordtype">int</span> dictSize);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271 <span class="comment">/*</span>
<a name="l00272"></a>00272 <span class="comment">*_continue() :</span>
<a name="l00273"></a>00273 <span class="comment">    These decoding functions allow decompression of multiple blocks in &quot;streaming&quot; mode.</span>
<a name="l00274"></a>00274 <span class="comment">    Previously decoded blocks *must* remain available at the memory position where they were decoded (up to 64 KB)</span>
<a name="l00275"></a>00275 <span class="comment">    In the case of a ring buffers, decoding buffer must be either :</span>
<a name="l00276"></a>00276 <span class="comment">    - Exactly same size as encoding buffer, with same update rule (block boundaries at same positions)</span>
<a name="l00277"></a>00277 <span class="comment">      In which case, the decoding &amp; encoding ring buffer can have any size, including very small ones ( &lt; 64 KB).</span>
<a name="l00278"></a>00278 <span class="comment">    - Larger than encoding buffer, by a minimum of maxBlockSize more bytes.</span>
<a name="l00279"></a>00279 <span class="comment">      maxBlockSize is implementation dependent. It&#39;s the maximum size you intend to compress into a single block.</span>
<a name="l00280"></a>00280 <span class="comment">      In which case, encoding and decoding buffers do not need to be synchronized,</span>
<a name="l00281"></a>00281 <span class="comment">      and encoding ring buffer can have any size, including small ones ( &lt; 64 KB).</span>
<a name="l00282"></a>00282 <span class="comment">    - _At least_ 64 KB + 8 bytes + maxBlockSize.</span>
<a name="l00283"></a>00283 <span class="comment">      In which case, encoding and decoding buffers do not need to be synchronized,</span>
<a name="l00284"></a>00284 <span class="comment">      and encoding ring buffer can have any size, including larger than decoding buffer.</span>
<a name="l00285"></a>00285 <span class="comment">    Whenever these conditions are not possible, save the last 64KB of decoded data into a safe buffer,</span>
<a name="l00286"></a>00286 <span class="comment">    and indicate where it is saved using LZ4_setStreamDecode()</span>
<a name="l00287"></a>00287 <span class="comment">*/</span>
<a name="l00288"></a>00288 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#af0dfa40b19b99035c9a8a962a2012dae">LZ4_decompress_safe_continue</a> (<a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* LZ4_streamDecode, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> maxDecompressedSize);
<a name="l00289"></a>00289 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#acfb9c80632c155cdb7cce498ae1c88bc">LZ4_decompress_fast_continue</a> (<a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* LZ4_streamDecode, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> originalSize);
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 
<a name="l00292"></a>00292 <span class="comment">/*</span>
<a name="l00293"></a>00293 <span class="comment">Advanced decoding functions :</span>
<a name="l00294"></a>00294 <span class="comment">*_usingDict() :</span>
<a name="l00295"></a>00295 <span class="comment">    These decoding functions work the same as</span>
<a name="l00296"></a>00296 <span class="comment">    a combination of LZ4_setStreamDecode() followed by LZ4_decompress_x_continue()</span>
<a name="l00297"></a>00297 <span class="comment">    They are stand-alone. They don&#39;t need nor update an LZ4_streamDecode_t structure.</span>
<a name="l00298"></a>00298 <span class="comment">*/</span>
<a name="l00299"></a>00299 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a36c8331cc4609de05d87da6c0eea574e">LZ4_decompress_safe_usingDict</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> maxDecompressedSize, <span class="keyword">const</span> <span class="keywordtype">char</span>* dictStart, <span class="keywordtype">int</span> dictSize);
<a name="l00300"></a>00300 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a1af9f7a2df20389dd9a0a31706c683b7">LZ4_decompress_fast_usingDict</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> originalSize, <span class="keyword">const</span> <span class="keywordtype">char</span>* dictStart, <span class="keywordtype">int</span> dictSize);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="comment">/**************************************</span>
<a name="l00305"></a>00305 <span class="comment">*  Obsolete Functions</span>
<a name="l00306"></a>00306 <span class="comment">**************************************/</span>
<a name="l00307"></a>00307 <span class="comment">/* Deprecate Warnings */</span>
<a name="l00308"></a>00308 <span class="comment">/* Should these warnings messages be a problem,</span>
<a name="l00309"></a>00309 <span class="comment">   it is generally possible to disable them,</span>
<a name="l00310"></a>00310 <span class="comment">   with -Wno-deprecated-declarations for gcc</span>
<a name="l00311"></a>00311 <span class="comment">   or _CRT_SECURE_NO_WARNINGS in Visual for example.</span>
<a name="l00312"></a>00312 <span class="comment">   You can also define LZ4_DEPRECATE_WARNING_DEFBLOCK. */</span>
<a name="l00313"></a>00313 <span class="preprocessor">#ifndef LZ4_DEPRECATE_WARNING_DEFBLOCK</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span><span class="preprocessor">#  define LZ4_DEPRECATE_WARNING_DEFBLOCK</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span><span class="preprocessor">#  define LZ4_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span><span class="preprocessor">#  if (LZ4_GCC_VERSION &gt;= 405) || defined(__clang__)</span>
<a name="l00317"></a>00317 <span class="preprocessor"></span><span class="preprocessor">#    define LZ4_DEPRECATED(message) __attribute__((deprecated(message)))</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span><span class="preprocessor">#  elif (LZ4_GCC_VERSION &gt;= 301)</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span><span class="preprocessor">#    define LZ4_DEPRECATED(message) __attribute__((deprecated))</span>
<a name="l00320"></a>00320 <span class="preprocessor"></span><span class="preprocessor">#  elif defined(_MSC_VER)</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span><span class="preprocessor">#    define LZ4_DEPRECATED(message) __declspec(deprecated(message))</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span><span class="preprocessor">#  else</span>
<a name="l00323"></a>00323 <span class="preprocessor"></span><span class="preprocessor">#    pragma message(&quot;WARNING: You need to implement LZ4_DEPRECATED for this compiler&quot;)</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span><span class="preprocessor">#    define LZ4_DEPRECATED(message)</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* LZ4_DEPRECATE_WARNING_DEFBLOCK */</span>
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="comment">/* Obsolete compression functions */</span>
<a name="l00329"></a>00329 <span class="comment">/* These functions are planned to start generate warnings by r131 approximately */</span>
<a name="l00330"></a>00330 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a806e7d86885991c722172bcf57abb71b">LZ4_compress</a>               (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> sourceSize);
<a name="l00331"></a>00331 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a464e8e2a2ad215e0d94042722eb75551">LZ4_compress_limitedOutput</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> sourceSize, <span class="keywordtype">int</span> maxOutputSize);
<a name="l00332"></a>00332 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a9fa2e6e61caea57ae1c3ef996f0e9ac9">LZ4_compress_withState</a>               (<span class="keywordtype">void</span>* state, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize);
<a name="l00333"></a>00333 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#ab9e6911a8271745f3a45490edeae135b">LZ4_compress_limitedOutput_withState</a> (<span class="keywordtype">void</span>* state, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize, <span class="keywordtype">int</span> maxOutputSize);
<a name="l00334"></a>00334 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a7936aa7dce7ba045f7daa578de555175">LZ4_compress_continue</a>                (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* LZ4_streamPtr, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize);
<a name="l00335"></a>00335 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a2c7e8a92e061237954e1cb1d18a38160">LZ4_compress_limitedOutput_continue</a>  (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* LZ4_streamPtr, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize, <span class="keywordtype">int</span> maxOutputSize);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="comment">/* Obsolete decompression functions */</span>
<a name="l00338"></a>00338 <span class="comment">/* These function names are completely deprecated and must no longer be used.</span>
<a name="l00339"></a>00339 <span class="comment">   They are only provided here for compatibility with older programs.</span>
<a name="l00340"></a>00340 <span class="comment">    - LZ4_uncompress is the same as LZ4_decompress_fast</span>
<a name="l00341"></a>00341 <span class="comment">    - LZ4_uncompress_unknownOutputSize is the same as LZ4_decompress_safe</span>
<a name="l00342"></a>00342 <span class="comment">   These function prototypes are now disabled; uncomment them only if you really need them.</span>
<a name="l00343"></a>00343 <span class="comment">   It is highly recommended to stop using these prototypes and migrate to maintained ones */</span>
<a name="l00344"></a>00344 <span class="comment">/* int LZ4_uncompress (const char* source, char* dest, int outputSize); */</span>
<a name="l00345"></a>00345 <span class="comment">/* int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize); */</span>
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <span class="comment">/* Obsolete streaming functions; use new streaming interface whenever possible */</span>
<a name="l00348"></a>00348 LZ4_DEPRECATED(<span class="stringliteral">&quot;use LZ4_createStream() instead&quot;</span>) void* <a class="code" href="lz4_8c.html#a3bc34ce06f00512001d0b5ffd1780b6d">LZ4_create</a> (<span class="keywordtype">char</span>* inputBuffer);
<a name="l00349"></a>00349 LZ4_DEPRECATED(&quot;use <a class="code" href="lz4_8c.html#a2ee12bd94227e0c76a3b686eee813c91">LZ4_createStream</a>() instead&quot;) <span class="keywordtype">int</span>   <a class="code" href="lz4_8c.html#a1fddf246561e7b13fb1b3b10aad55045">LZ4_sizeofStreamState</a>(<span class="keywordtype">void</span>);
<a name="l00350"></a>00350 LZ4_DEPRECATED(&quot;use <a class="code" href="lz4_8c.html#a62d9f1ebf60fd83bf2f0d1a58e80a64c">LZ4_resetStream</a>() instead&quot;)  <span class="keywordtype">int</span>   <a class="code" href="lz4_8c.html#acc12a443b49ec045db2399d57c0afde7">LZ4_resetStreamState</a>(<span class="keywordtype">void</span>* state, <span class="keywordtype">char</span>* inputBuffer);
<a name="l00351"></a>00351 LZ4_DEPRECATED(&quot;use <a class="code" href="lz4_8c.html#abb233b63fc3488ce647ee9c7b0a95a76">LZ4_saveDict</a>() instead&quot;)     <span class="keywordtype">char</span>* <a class="code" href="lz4_8c.html#a2fd193cdf3113ab39f312a6cf625e988">LZ4_slideInputBuffer</a> (<span class="keywordtype">void</span>* state);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <span class="comment">/* Obsolete streaming decoding functions */</span>
<a name="l00354"></a>00354 LZ4_DEPRECATED(&quot;use <a class="code" href="lz4_8c.html#a36c8331cc4609de05d87da6c0eea574e">LZ4_decompress_safe_usingDict</a>() instead&quot;) <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a2ea4e15e70c6c9fb4c33c2e47bdf6c57">LZ4_decompress_safe_withPrefix64k</a> (const <span class="keywordtype">char</span>* src, <span class="keywordtype">char</span>* dst, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> maxDstSize);
<a name="l00355"></a>00355 LZ4_DEPRECATED(&quot;use <a class="code" href="lz4_8c.html#a1af9f7a2df20389dd9a0a31706c683b7">LZ4_decompress_fast_usingDict</a>() instead&quot;) <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#aef3d7b7bead970344b439ac9bd672065">LZ4_decompress_fast_withPrefix64k</a> (const <span class="keywordtype">char</span>* src, <span class="keywordtype">char</span>* dst, <span class="keywordtype">int</span> originalSize);
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="preprocessor">#if defined (__cplusplus)</span>
<a name="l00359"></a>00359 <span class="preprocessor"></span>}
<a name="l00360"></a>00360 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 4 2015 18:06:13 for ROSS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ROSS: core/lz4.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ROSS
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">core/lz4.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="lz4_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">   LZ4 - Fast LZ compression algorithm</span>
<a name="l00003"></a>00003 <span class="comment">   Header File</span>
<a name="l00004"></a>00004 <span class="comment">   Copyright (C) 2011-2014, Yann Collet.</span>
<a name="l00005"></a>00005 <span class="comment">   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   Redistribution and use in source and binary forms, with or without</span>
<a name="l00008"></a>00008 <span class="comment">   modification, are permitted provided that the following conditions are</span>
<a name="l00009"></a>00009 <span class="comment">   met:</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">       * Redistributions of source code must retain the above copyright</span>
<a name="l00012"></a>00012 <span class="comment">   notice, this list of conditions and the following disclaimer.</span>
<a name="l00013"></a>00013 <span class="comment">       * Redistributions in binary form must reproduce the above</span>
<a name="l00014"></a>00014 <span class="comment">   copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00015"></a>00015 <span class="comment">   in the documentation and/or other materials provided with the</span>
<a name="l00016"></a>00016 <span class="comment">   distribution.</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00019"></a>00019 <span class="comment">   &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00020"></a>00020 <span class="comment">   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00021"></a>00021 <span class="comment">   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00022"></a>00022 <span class="comment">   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00023"></a>00023 <span class="comment">   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00024"></a>00024 <span class="comment">   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00025"></a>00025 <span class="comment">   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00026"></a>00026 <span class="comment">   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00027"></a>00027 <span class="comment">   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00028"></a>00028 <span class="comment">   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment">   You can contact the author at :</span>
<a name="l00031"></a>00031 <span class="comment">   - LZ4 source repository : http://code.google.com/p/lz4/</span>
<a name="l00032"></a>00032 <span class="comment">   - LZ4 public forum : https://groups.google.com/forum/#!forum/lz4c</span>
<a name="l00033"></a>00033 <span class="comment">*/</span>
<a name="l00034"></a>00034 <span class="preprocessor">#pragma once</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#if defined (__cplusplus)</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00038"></a>00038 <span class="preprocessor">#endif</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="comment">/*</span>
<a name="l00041"></a>00041 <span class="comment"> * lz4.h provides raw compression format functions, for optimal performance and integration into programs.</span>
<a name="l00042"></a>00042 <span class="comment"> * If you need to generate data using an inter-operable format (respecting the framing specification),</span>
<a name="l00043"></a>00043 <span class="comment"> * please use lz4frame.h instead.</span>
<a name="l00044"></a>00044 <span class="comment">*/</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="comment">/**************************************</span>
<a name="l00047"></a>00047 <span class="comment">   Version</span>
<a name="l00048"></a>00048 <span class="comment">**************************************/</span>
<a name="l00049"></a><a class="code" href="lz4_8h.html#a4a15eb1f8aa69834f917a50d7652413e">00049</a> <span class="preprocessor">#define LZ4_VERSION_MAJOR    1    </span><span class="comment">/* for major interface/format changes  */</span>
<a name="l00050"></a><a class="code" href="lz4_8h.html#af16952f74f68ac445da9fc7603609909">00050</a> <span class="preprocessor">#define LZ4_VERSION_MINOR    4    </span><span class="comment">/* for minor interface/format changes  */</span>
<a name="l00051"></a><a class="code" href="lz4_8h.html#a19d496bbe4d8448bc2d42cfb576cf525">00051</a> <span class="preprocessor">#define LZ4_VERSION_RELEASE  1    </span><span class="comment">/* for tweaks, bug-fixes, or development */</span>
<a name="l00052"></a><a class="code" href="lz4_8h.html#aac7e910a11c45364a8b235d0d43a0265">00052</a> <span class="preprocessor">#define LZ4_VERSION_NUMBER (LZ4_VERSION_MAJOR *100*100 + LZ4_VERSION_MINOR *100 + LZ4_VERSION_RELEASE)</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a9a7a69397b6452fcf6a35caa40493776">LZ4_versionNumber</a> (<span class="keywordtype">void</span>);
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">/**************************************</span>
<a name="l00056"></a>00056 <span class="comment">   Tuning parameter</span>
<a name="l00057"></a>00057 <span class="comment">**************************************/</span>
<a name="l00058"></a>00058 <span class="comment">/*</span>
<a name="l00059"></a>00059 <span class="comment"> * LZ4_MEMORY_USAGE :</span>
<a name="l00060"></a>00060 <span class="comment"> * Memory usage formula : N-&gt;2^N Bytes (examples : 10 -&gt; 1KB; 12 -&gt; 4KB ; 16 -&gt; 64KB; 20 -&gt; 1MB; etc.)</span>
<a name="l00061"></a>00061 <span class="comment"> * Increasing memory usage improves compression ratio</span>
<a name="l00062"></a>00062 <span class="comment"> * Reduced memory usage can improve speed, due to cache effect</span>
<a name="l00063"></a>00063 <span class="comment"> * Default value is 14, for 16KB, which nicely fits into Intel x86 L1 cache</span>
<a name="l00064"></a>00064 <span class="comment"> */</span>
<a name="l00065"></a><a class="code" href="lz4_8h.html#a24ddbc39e7379532031a91357e66a32c">00065</a> <span class="preprocessor">#define LZ4_MEMORY_USAGE 14</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span>
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">/**************************************</span>
<a name="l00069"></a>00069 <span class="comment">   Simple Functions</span>
<a name="l00070"></a>00070 <span class="comment">**************************************/</span>
<a name="l00071"></a>00071 
<a name="l00072"></a>00072 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a806e7d86885991c722172bcf57abb71b">LZ4_compress</a>        (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> sourceSize);
<a name="l00073"></a>00073 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a0826f3dc340fdea6dfa985f6ac26642f">LZ4_decompress_safe</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> maxDecompressedSize);
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="comment">/*</span>
<a name="l00076"></a>00076 <span class="comment">LZ4_compress() :</span>
<a name="l00077"></a>00077 <span class="comment">    Compresses &#39;sourceSize&#39; bytes from &#39;source&#39; into &#39;dest&#39;.</span>
<a name="l00078"></a>00078 <span class="comment">    Destination buffer must be already allocated,</span>
<a name="l00079"></a>00079 <span class="comment">    and must be sized to handle worst cases situations (input data not compressible)</span>
<a name="l00080"></a>00080 <span class="comment">    Worst case size evaluation is provided by function LZ4_compressBound()</span>
<a name="l00081"></a>00081 <span class="comment">    inputSize : Max supported value is LZ4_MAX_INPUT_SIZE</span>
<a name="l00082"></a>00082 <span class="comment">    return : the number of bytes written in buffer dest</span>
<a name="l00083"></a>00083 <span class="comment">             or 0 if the compression fails</span>
<a name="l00084"></a>00084 <span class="comment"></span>
<a name="l00085"></a>00085 <span class="comment">LZ4_decompress_safe() :</span>
<a name="l00086"></a>00086 <span class="comment">    compressedSize : is obviously the source size</span>
<a name="l00087"></a>00087 <span class="comment">    maxDecompressedSize : is the size of the destination buffer, which must be already allocated.</span>
<a name="l00088"></a>00088 <span class="comment">    return : the number of bytes decompressed into the destination buffer (necessarily &lt;= maxDecompressedSize)</span>
<a name="l00089"></a>00089 <span class="comment">             If the destination buffer is not large enough, decoding will stop and output an error code (&lt;0).</span>
<a name="l00090"></a>00090 <span class="comment">             If the source stream is detected malformed, the function will stop decoding and return a negative result.</span>
<a name="l00091"></a>00091 <span class="comment">             This function is protected against buffer overflow exploits,</span>
<a name="l00092"></a>00092 <span class="comment">             and never writes outside of output buffer, nor reads outside of input buffer.</span>
<a name="l00093"></a>00093 <span class="comment">             It is also protected against malicious data packets.</span>
<a name="l00094"></a>00094 <span class="comment">*/</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">/**************************************</span>
<a name="l00098"></a>00098 <span class="comment">   Advanced Functions</span>
<a name="l00099"></a>00099 <span class="comment">**************************************/</span>
<a name="l00100"></a><a class="code" href="lz4_8h.html#a88ee51e36ca74cd0533e731c20572ea6">00100</a> <span class="preprocessor">#define LZ4_MAX_INPUT_SIZE        0x7E000000   </span><span class="comment">/* 2 113 929 216 bytes */</span>
<a name="l00101"></a><a class="code" href="lz4_8h.html#a2453a423fd34640a0afbbf57ed0a5399">00101</a> <span class="preprocessor">#define LZ4_COMPRESSBOUND(isize)  ((unsigned int)(isize) &gt; (unsigned int)LZ4_MAX_INPUT_SIZE ? 0 : (isize) + ((isize)/255) + 16)</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="comment">/*</span>
<a name="l00104"></a>00104 <span class="comment">LZ4_compressBound() :</span>
<a name="l00105"></a>00105 <span class="comment">    Provides the maximum size that LZ4 compression may output in a &quot;worst case&quot; scenario (input data not compressible)</span>
<a name="l00106"></a>00106 <span class="comment">    This function is primarily useful for memory allocation purposes (output buffer size).</span>
<a name="l00107"></a>00107 <span class="comment">    Macro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).</span>
<a name="l00108"></a>00108 <span class="comment"></span>
<a name="l00109"></a>00109 <span class="comment">    isize  : is the input size. Max supported value is LZ4_MAX_INPUT_SIZE</span>
<a name="l00110"></a>00110 <span class="comment">    return : maximum output size in a &quot;worst case&quot; scenario</span>
<a name="l00111"></a>00111 <span class="comment">             or 0, if input size is too large ( &gt; LZ4_MAX_INPUT_SIZE)</span>
<a name="l00112"></a>00112 <span class="comment">*/</span>
<a name="l00113"></a>00113 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a2b09f5ca41ce609bb136d3637beffe04">LZ4_compressBound</a>(<span class="keywordtype">int</span> isize);
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="comment">/*</span>
<a name="l00117"></a>00117 <span class="comment">LZ4_compress_limitedOutput() :</span>
<a name="l00118"></a>00118 <span class="comment">    Compress &#39;sourceSize&#39; bytes from &#39;source&#39; into an output buffer &#39;dest&#39; of maximum size &#39;maxOutputSize&#39;.</span>
<a name="l00119"></a>00119 <span class="comment">    If it cannot achieve it, compression will stop, and result of the function will be zero.</span>
<a name="l00120"></a>00120 <span class="comment">    This saves time and memory on detecting non-compressible (or barely compressible) data.</span>
<a name="l00121"></a>00121 <span class="comment">    This function never writes outside of provided output buffer.</span>
<a name="l00122"></a>00122 <span class="comment"></span>
<a name="l00123"></a>00123 <span class="comment">    sourceSize  : Max supported value is LZ4_MAX_INPUT_VALUE</span>
<a name="l00124"></a>00124 <span class="comment">    maxOutputSize : is the size of the destination buffer (which must be already allocated)</span>
<a name="l00125"></a>00125 <span class="comment">    return : the number of bytes written in buffer &#39;dest&#39;</span>
<a name="l00126"></a>00126 <span class="comment">             or 0 if compression fails</span>
<a name="l00127"></a>00127 <span class="comment">*/</span>
<a name="l00128"></a>00128 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a464e8e2a2ad215e0d94042722eb75551">LZ4_compress_limitedOutput</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> sourceSize, <span class="keywordtype">int</span> maxOutputSize);
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="comment">/*</span>
<a name="l00132"></a>00132 <span class="comment">LZ4_compress_withState() :</span>
<a name="l00133"></a>00133 <span class="comment">    Same compression functions, but using an externally allocated memory space to store compression state.</span>
<a name="l00134"></a>00134 <span class="comment">    Use LZ4_sizeofState() to know how much memory must be allocated,</span>
<a name="l00135"></a>00135 <span class="comment">    and then, provide it as &#39;void* state&#39; to compression functions.</span>
<a name="l00136"></a>00136 <span class="comment">*/</span>
<a name="l00137"></a>00137 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#aa7ea35a4a6f3c9b29dbbd14939706c53">LZ4_sizeofState</a>(<span class="keywordtype">void</span>);
<a name="l00138"></a>00138 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a430f331e5951658bd033faf564a958bf">LZ4_compress_withState</a>               (<span class="keywordtype">void</span>* state, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize);
<a name="l00139"></a>00139 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#aae32f2434789e3878e43f52094b81b9a">LZ4_compress_limitedOutput_withState</a> (<span class="keywordtype">void</span>* state, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize, <span class="keywordtype">int</span> maxOutputSize);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="comment">/*</span>
<a name="l00143"></a>00143 <span class="comment">LZ4_decompress_fast() :</span>
<a name="l00144"></a>00144 <span class="comment">    originalSize : is the original and therefore uncompressed size</span>
<a name="l00145"></a>00145 <span class="comment">    return : the number of bytes read from the source buffer (in other words, the compressed size)</span>
<a name="l00146"></a>00146 <span class="comment">             If the source stream is detected malformed, the function will stop decoding and return a negative result.</span>
<a name="l00147"></a>00147 <span class="comment">             Destination buffer must be already allocated. Its size must be a minimum of &#39;originalSize&#39; bytes.</span>
<a name="l00148"></a>00148 <span class="comment">    note : This function fully respect memory boundaries for properly formed compressed data.</span>
<a name="l00149"></a>00149 <span class="comment">           It is a bit faster than LZ4_decompress_safe().</span>
<a name="l00150"></a>00150 <span class="comment">           However, it does not provide any protection against intentionally modified data stream (malicious input).</span>
<a name="l00151"></a>00151 <span class="comment">           Use this function in trusted environment only (data to decode comes from a trusted source).</span>
<a name="l00152"></a>00152 <span class="comment">*/</span>
<a name="l00153"></a>00153 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a1b6fd5873bbe60abc9a6bf7b3e75056a">LZ4_decompress_fast</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> originalSize);
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="comment">/*</span>
<a name="l00157"></a>00157 <span class="comment">LZ4_decompress_safe_partial() :</span>
<a name="l00158"></a>00158 <span class="comment">    This function decompress a compressed block of size &#39;compressedSize&#39; at position &#39;source&#39;</span>
<a name="l00159"></a>00159 <span class="comment">    into destination buffer &#39;dest&#39; of size &#39;maxDecompressedSize&#39;.</span>
<a name="l00160"></a>00160 <span class="comment">    The function tries to stop decompressing operation as soon as &#39;targetOutputSize&#39; has been reached,</span>
<a name="l00161"></a>00161 <span class="comment">    reducing decompression time.</span>
<a name="l00162"></a>00162 <span class="comment">    return : the number of bytes decoded in the destination buffer (necessarily &lt;= maxDecompressedSize)</span>
<a name="l00163"></a>00163 <span class="comment">       Note : this number can be &lt; &#39;targetOutputSize&#39; should the compressed block to decode be smaller.</span>
<a name="l00164"></a>00164 <span class="comment">             Always control how many bytes were decoded.</span>
<a name="l00165"></a>00165 <span class="comment">             If the source stream is detected malformed, the function will stop decoding and return a negative result.</span>
<a name="l00166"></a>00166 <span class="comment">             This function never writes outside of output buffer, and never reads outside of input buffer. It is therefore protected against malicious data packets</span>
<a name="l00167"></a>00167 <span class="comment">*/</span>
<a name="l00168"></a>00168 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a32ad048b557cd0bd1134cc8221dca208">LZ4_decompress_safe_partial</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> targetOutputSize, <span class="keywordtype">int</span> maxDecompressedSize);
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="comment">/***********************************************</span>
<a name="l00172"></a>00172 <span class="comment">   Streaming Compression Functions</span>
<a name="l00173"></a>00173 <span class="comment">***********************************************/</span>
<a name="l00174"></a>00174 
<a name="l00175"></a><a class="code" href="lz4_8h.html#acddbce79f3e1d413f295e97d986ab3f5">00175</a> <span class="preprocessor">#define LZ4_STREAMSIZE_U64 ((1 &lt;&lt; (LZ4_MEMORY_USAGE-3)) + 4)</span>
<a name="l00176"></a><a class="code" href="lz4_8h.html#a1b76402ebadac569ceb550cb22a7a6e4">00176</a> <span class="preprocessor"></span><span class="preprocessor">#define LZ4_STREAMSIZE     (LZ4_STREAMSIZE_U64 * sizeof(long long))</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00178"></a>00178 <span class="comment"> * LZ4_stream_t</span>
<a name="l00179"></a>00179 <span class="comment"> * information structure to track an LZ4 stream.</span>
<a name="l00180"></a>00180 <span class="comment"> * important : init this structure content before first use !</span>
<a name="l00181"></a>00181 <span class="comment"> * note : only allocated directly the structure if you are statically linking LZ4</span>
<a name="l00182"></a>00182 <span class="comment"> *        If you are using liblz4 as a DLL, please use below construction methods instead.</span>
<a name="l00183"></a>00183 <span class="comment"> */</span>
<a name="l00184"></a><a class="code" href="structLZ4__stream__t.html#ae4d6a1e6e680c9d9b3c3ea383da1d948">00184</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">long</span> <span class="keywordtype">long</span> table[<a class="code" href="lz4_8h.html#acddbce79f3e1d413f295e97d986ab3f5">LZ4_STREAMSIZE_U64</a>]; } <a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">/*</span>
<a name="l00187"></a>00187 <span class="comment"> * LZ4_resetStream</span>
<a name="l00188"></a>00188 <span class="comment"> * Use this function to init an allocated LZ4_stream_t structure</span>
<a name="l00189"></a>00189 <span class="comment"> */</span>
<a name="l00190"></a>00190 <span class="keywordtype">void</span> <a class="code" href="lz4_8c.html#a62d9f1ebf60fd83bf2f0d1a58e80a64c">LZ4_resetStream</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* LZ4_streamPtr);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="comment">/*</span>
<a name="l00193"></a>00193 <span class="comment"> * LZ4_createStream will allocate and initialize an LZ4_stream_t structure</span>
<a name="l00194"></a>00194 <span class="comment"> * LZ4_freeStream releases its memory.</span>
<a name="l00195"></a>00195 <span class="comment"> * In the context of a DLL (liblz4), please use these methods rather than the static struct.</span>
<a name="l00196"></a>00196 <span class="comment"> * They are more future proof, in case of a change of LZ4_stream_t size.</span>
<a name="l00197"></a>00197 <span class="comment"> */</span>
<a name="l00198"></a>00198 <a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* <a class="code" href="lz4_8c.html#a2ee12bd94227e0c76a3b686eee813c91">LZ4_createStream</a>(<span class="keywordtype">void</span>);
<a name="l00199"></a>00199 <span class="keywordtype">int</span>           <a class="code" href="lz4_8c.html#a6a4702cac776d39c52074280d8fb84db">LZ4_freeStream</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* LZ4_streamPtr);
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="comment">/*</span>
<a name="l00202"></a>00202 <span class="comment"> * LZ4_loadDict</span>
<a name="l00203"></a>00203 <span class="comment"> * Use this function to load a static dictionary into LZ4_stream.</span>
<a name="l00204"></a>00204 <span class="comment"> * Any previous data will be forgotten, only &#39;dictionary&#39; will remain in memory.</span>
<a name="l00205"></a>00205 <span class="comment"> * Loading a size of 0 is allowed.</span>
<a name="l00206"></a>00206 <span class="comment"> * Return : dictionary size, in bytes (necessarily &lt;= 64 KB)</span>
<a name="l00207"></a>00207 <span class="comment"> */</span>
<a name="l00208"></a>00208 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a2b94615ba633a2c5511758d5f2cb34f5">LZ4_loadDict</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* LZ4_streamPtr, <span class="keyword">const</span> <span class="keywordtype">char</span>* dictionary, <span class="keywordtype">int</span> dictSize);
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="comment">/*</span>
<a name="l00211"></a>00211 <span class="comment"> * LZ4_compress_continue</span>
<a name="l00212"></a>00212 <span class="comment"> * Compress data block &#39;source&#39;, using blocks compressed before as dictionary to improve compression ratio</span>
<a name="l00213"></a>00213 <span class="comment"> * Previous data blocks are assumed to still be present at their previous location.</span>
<a name="l00214"></a>00214 <span class="comment"> */</span>
<a name="l00215"></a>00215 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a7936aa7dce7ba045f7daa578de555175">LZ4_compress_continue</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* LZ4_streamPtr, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize);
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="comment">/*</span>
<a name="l00218"></a>00218 <span class="comment"> * LZ4_compress_limitedOutput_continue</span>
<a name="l00219"></a>00219 <span class="comment"> * Same as before, but also specify a maximum target compressed size (maxOutputSize)</span>
<a name="l00220"></a>00220 <span class="comment"> * If objective cannot be met, compression exits, and returns a zero.</span>
<a name="l00221"></a>00221 <span class="comment"> */</span>
<a name="l00222"></a>00222 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a4002ac9d7d18f62dedff3349f41e63bf">LZ4_compress_limitedOutput_continue</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* LZ4_streamPtr, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> inputSize, <span class="keywordtype">int</span> maxOutputSize);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="comment">/*</span>
<a name="l00225"></a>00225 <span class="comment"> * LZ4_saveDict</span>
<a name="l00226"></a>00226 <span class="comment"> * If previously compressed data block is not guaranteed to remain available at its memory location</span>
<a name="l00227"></a>00227 <span class="comment"> * save it into a safer place (char* safeBuffer)</span>
<a name="l00228"></a>00228 <span class="comment"> * Note : you don&#39;t need to call LZ4_loadDict() afterwards,</span>
<a name="l00229"></a>00229 <span class="comment"> *        dictionary is immediately usable, you can therefore call again LZ4_compress_continue()</span>
<a name="l00230"></a>00230 <span class="comment"> * Return : dictionary size in bytes, or 0 if error</span>
<a name="l00231"></a>00231 <span class="comment"> * Note : any dictSize &gt; 64 KB will be interpreted as 64KB.</span>
<a name="l00232"></a>00232 <span class="comment"> */</span>
<a name="l00233"></a>00233 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#abb233b63fc3488ce647ee9c7b0a95a76">LZ4_saveDict</a> (<a class="code" href="structLZ4__stream__t.html">LZ4_stream_t</a>* LZ4_streamPtr, <span class="keywordtype">char</span>* safeBuffer, <span class="keywordtype">int</span> dictSize);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="comment">/************************************************</span>
<a name="l00237"></a>00237 <span class="comment">   Streaming Decompression Functions</span>
<a name="l00238"></a>00238 <span class="comment">************************************************/</span>
<a name="l00239"></a>00239 
<a name="l00240"></a><a class="code" href="lz4_8h.html#a414ecb38e0607f239de5ebca5a5beef5">00240</a> <span class="preprocessor">#define LZ4_STREAMDECODESIZE_U64  4</span>
<a name="l00241"></a><a class="code" href="lz4_8h.html#a9a08f1c4969b5e46eba93818cd7cb5a7">00241</a> <span class="preprocessor"></span><span class="preprocessor">#define LZ4_STREAMDECODESIZE     (LZ4_STREAMDECODESIZE_U64 * sizeof(unsigned long long))</span>
<a name="l00242"></a><a class="code" href="structLZ4__streamDecode__t.html#a26d8a3afb360f5fffff4fdb6e59b5ead">00242</a> <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> table[<a class="code" href="lz4_8h.html#a414ecb38e0607f239de5ebca5a5beef5">LZ4_STREAMDECODESIZE_U64</a>]; } <a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>;
<a name="l00243"></a>00243 <span class="comment">/*</span>
<a name="l00244"></a>00244 <span class="comment"> * LZ4_streamDecode_t</span>
<a name="l00245"></a>00245 <span class="comment"> * information structure to track an LZ4 stream.</span>
<a name="l00246"></a>00246 <span class="comment"> * init this structure content using LZ4_setStreamDecode or memset() before first use !</span>
<a name="l00247"></a>00247 <span class="comment"> *</span>
<a name="l00248"></a>00248 <span class="comment"> * In the context of a DLL (liblz4) please prefer usage of construction methods below.</span>
<a name="l00249"></a>00249 <span class="comment"> * They are more future proof, in case of a change of LZ4_streamDecode_t size in the future.</span>
<a name="l00250"></a>00250 <span class="comment"> * LZ4_createStreamDecode will allocate and initialize an LZ4_streamDecode_t structure</span>
<a name="l00251"></a>00251 <span class="comment"> * LZ4_freeStreamDecode releases its memory.</span>
<a name="l00252"></a>00252 <span class="comment"> */</span>
<a name="l00253"></a>00253 <a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* <a class="code" href="lz4_8c.html#a328b12424f9542cbc348b98482e455f5">LZ4_createStreamDecode</a>(<span class="keywordtype">void</span>);
<a name="l00254"></a>00254 <span class="keywordtype">int</span>                 <a class="code" href="lz4_8c.html#afdcbf92c1921ecf2838db322c77c1485">LZ4_freeStreamDecode</a> (<a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* LZ4_stream);
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="comment">/*</span>
<a name="l00257"></a>00257 <span class="comment"> * LZ4_setStreamDecode</span>
<a name="l00258"></a>00258 <span class="comment"> * Use this function to instruct where to find the dictionary.</span>
<a name="l00259"></a>00259 <span class="comment"> * Setting a size of 0 is allowed (same effect as reset).</span>
<a name="l00260"></a>00260 <span class="comment"> * Return : 1 if OK, 0 if error</span>
<a name="l00261"></a>00261 <span class="comment"> */</span>
<a name="l00262"></a>00262 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a971624e4abed2ab679a8c1728875663b">LZ4_setStreamDecode</a> (<a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* LZ4_streamDecode, <span class="keyword">const</span> <span class="keywordtype">char</span>* dictionary, <span class="keywordtype">int</span> dictSize);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="comment">/*</span>
<a name="l00265"></a>00265 <span class="comment">*_continue() :</span>
<a name="l00266"></a>00266 <span class="comment">    These decoding functions allow decompression of multiple blocks in &quot;streaming&quot; mode.</span>
<a name="l00267"></a>00267 <span class="comment">    Previously decoded blocks *must* remain available at the memory position where they were decoded (up to 64 KB)</span>
<a name="l00268"></a>00268 <span class="comment">    If this condition is not possible, save the relevant part of decoded data into a safe buffer,</span>
<a name="l00269"></a>00269 <span class="comment">    and indicate where is its new address using LZ4_setStreamDecode()</span>
<a name="l00270"></a>00270 <span class="comment">*/</span>
<a name="l00271"></a>00271 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#af0dfa40b19b99035c9a8a962a2012dae">LZ4_decompress_safe_continue</a> (<a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* LZ4_streamDecode, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> maxDecompressedSize);
<a name="l00272"></a>00272 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#acfb9c80632c155cdb7cce498ae1c88bc">LZ4_decompress_fast_continue</a> (<a class="code" href="structLZ4__streamDecode__t.html">LZ4_streamDecode_t</a>* LZ4_streamDecode, <span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> originalSize);
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="comment">/*</span>
<a name="l00276"></a>00276 <span class="comment">Advanced decoding functions :</span>
<a name="l00277"></a>00277 <span class="comment">*_usingDict() :</span>
<a name="l00278"></a>00278 <span class="comment">    These decoding functions work the same as</span>
<a name="l00279"></a>00279 <span class="comment">    a combination of LZ4_setDictDecode() followed by LZ4_decompress_x_continue()</span>
<a name="l00280"></a>00280 <span class="comment">    They are stand-alone and don&#39;t use nor update an LZ4_streamDecode_t structure.</span>
<a name="l00281"></a>00281 <span class="comment">*/</span>
<a name="l00282"></a>00282 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a36c8331cc4609de05d87da6c0eea574e">LZ4_decompress_safe_usingDict</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> maxDecompressedSize, <span class="keyword">const</span> <span class="keywordtype">char</span>* dictStart, <span class="keywordtype">int</span> dictSize);
<a name="l00283"></a>00283 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a1af9f7a2df20389dd9a0a31706c683b7">LZ4_decompress_fast_usingDict</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> originalSize, <span class="keyword">const</span> <span class="keywordtype">char</span>* dictStart, <span class="keywordtype">int</span> dictSize);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 <span class="comment">/**************************************</span>
<a name="l00288"></a>00288 <span class="comment">   Obsolete Functions</span>
<a name="l00289"></a>00289 <span class="comment">**************************************/</span>
<a name="l00290"></a>00290 <span class="comment">/*</span>
<a name="l00291"></a>00291 <span class="comment">Obsolete decompression functions</span>
<a name="l00292"></a>00292 <span class="comment">These function names are deprecated and should no longer be used.</span>
<a name="l00293"></a>00293 <span class="comment">They are only provided here for compatibility with older user programs.</span>
<a name="l00294"></a>00294 <span class="comment">- LZ4_uncompress is the same as LZ4_decompress_fast</span>
<a name="l00295"></a>00295 <span class="comment">- LZ4_uncompress_unknownOutputSize is the same as LZ4_decompress_safe</span>
<a name="l00296"></a>00296 <span class="comment">These function prototypes are now disabled; uncomment them if you really need them.</span>
<a name="l00297"></a>00297 <span class="comment">It is highly recommended to stop using these functions and migrate to newer ones */</span>
<a name="l00298"></a>00298 <span class="comment">/* int LZ4_uncompress (const char* source, char* dest, int outputSize); */</span>
<a name="l00299"></a>00299 <span class="comment">/* int LZ4_uncompress_unknownOutputSize (const char* source, char* dest, int isize, int maxOutputSize); */</span>
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="comment">/* Obsolete streaming functions; use new streaming interface whenever possible */</span>
<a name="l00303"></a>00303 <span class="keywordtype">void</span>* <a class="code" href="lz4_8c.html#a3aa16d37ad77d8007ffaa0bdb3c7fb10">LZ4_create</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* inputBuffer);
<a name="l00304"></a>00304 <span class="keywordtype">int</span>   <a class="code" href="lz4_8c.html#a1fddf246561e7b13fb1b3b10aad55045">LZ4_sizeofStreamState</a>(<span class="keywordtype">void</span>);
<a name="l00305"></a>00305 <span class="keywordtype">int</span>   <a class="code" href="lz4_8c.html#ae29eae664f704fd216b9db8d05d51e18">LZ4_resetStreamState</a>(<span class="keywordtype">void</span>* state, <span class="keyword">const</span> <span class="keywordtype">char</span>* inputBuffer);
<a name="l00306"></a>00306 <span class="keywordtype">char</span>* <a class="code" href="lz4_8c.html#a2fd193cdf3113ab39f312a6cf625e988">LZ4_slideInputBuffer</a> (<span class="keywordtype">void</span>* state);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="comment">/* Obsolete streaming decoding functions */</span>
<a name="l00309"></a>00309 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#a2ea4e15e70c6c9fb4c33c2e47bdf6c57">LZ4_decompress_safe_withPrefix64k</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> compressedSize, <span class="keywordtype">int</span> maxOutputSize);
<a name="l00310"></a>00310 <span class="keywordtype">int</span> <a class="code" href="lz4_8c.html#aef3d7b7bead970344b439ac9bd672065">LZ4_decompress_fast_withPrefix64k</a> (<span class="keyword">const</span> <span class="keywordtype">char</span>* source, <span class="keywordtype">char</span>* dest, <span class="keywordtype">int</span> originalSize);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="preprocessor">#if defined (__cplusplus)</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>}
<a name="l00315"></a>00315 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu May 14 2015 18:49:33 for ROSS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
